<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>目标导向系统</title>
  
  <subtitle>探索通用智能机器之路</subtitle>
  <link href="http://blog.joypace.com/atom.xml" rel="self"/>
  
  <link href="http://blog.joypace.com/"/>
  <updated>2022-03-27T15:04:12.775Z</updated>
  <id>http://blog.joypace.com/</id>
  
  <author>
    <name>Joypace.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抽象概念</title>
    <link href="http://blog.joypace.com/2022/03/27/AbstractConcepts/"/>
    <id>http://blog.joypace.com/2022/03/27/AbstractConcepts/</id>
    <published>2022-03-27T07:42:46.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>在机器人对世界进行建模时，不可避免的需要识别和编码各种抽象的概念。即使是最最基础的事物，其特性都“隐含”有抽象的概念。 比如思维时空中某一个点，它的特性中至少包含四个维度上离远点的距离，即坐标；还包含N个基础属性的强度。由此可以看出，抽象概念并不是主体凭空想象出来的，而是客观世界的一部分。虽然抽象概念不能在时空中<strong>独立存在</strong>，但是时空中却处处都出现了抽象概念。</p><span id="more"></span><p>对于很多人来说，一提到抽象概念，就会想到数学，想到各种是枯燥，烧脑的概念。确实数学的研究对象基本上都是抽象的概念，如实数，计算，集合，映射，概率，拓扑结构等等。实际上，除了数学之外，人们日常生活中识别和应用了大量的抽象概念。比如在社交生活中，我们发现这个人正直，那个人很有激情，另一个人看上去很凶等等。这里<em>正直，激情，凶</em>都是抽象概念。甚至很多我们觉得很具体的概念，其实也是抽象概念，比如我们对事物的分类。水果是对很多具体的物品的统称，但<em>水果</em>本身是一个抽象的概念，是一个集合。人们对抽象概念的识别，最终的目标还是应用。比如我们会根据对他人品质的判断来调整自己的行为，会根据对事品类别的理解，来判断其应用价值等等。</p><h2 id="识别和表示抽象概念"><a href="#识别和表示抽象概念" class="headerlink" title="识别和表示抽象概念"></a>识别和表示抽象概念</h2><p><em>集合</em>是一种最基础的抽象概念，几乎所有的抽象概念都可以基于集合来定义。我们以集合为例，梳理一下机器人可以如何识别客观世界中的集合。</p><p>如果机器人需要表示客观世界中两个不同的事物，那它们必须是可区分的，因此，其对应的编码也应该是可区分的。那现实中的两个事物形成了一个集合<em>Reality</em>，表示空间中的“两个编码”也形成了一个集合<em>Notation</em>。机器人识别<em>Reality</em>并记录<em>Notation</em>的过程实际上是一个从<em>Reality</em>到<em>Notation</em>的映射过程。整个映射过程分为两步：</p><ol><li>现实中的事物<em>Reality</em>与机器人的“感官子系统”在物理定律的约束下，产生一系列的相互作用，使得机器人接收到了相关的物理信号，并且不同事物的信号是可区分的。</li><li>机器人的“认知子系统”基于接收到的信号进行相应的计算，得到不同事物的内部编码，从而得到<em>Notation</em> 集合</li></ol><h2 id="“无限”集合"><a href="#“无限”集合" class="headerlink" title="“无限”集合"></a>“无限”集合</h2><p>“无限”集合是一个非常重要的抽象概念，人们日常生活中和科学研究中都会遇到“无限集合”，比如自然数，宇宙的“直径”等等。对于有限的集合，我们可以简单的有列表枚举来表示，即我们只需要给每个集合中的元素赋予一个不同的id就行了。如果要表示集合元素很多或者是无限多是，显然我们就不能使用枚举来表示这个集合了。这时候就需要使用规则来表示了。规则实际上就是计算，而计算本身也可以用集合来表示。但要表示无限的集合，最终一定需要依赖到需要用无限集合表示的计算。所以最终问题就转化为如何表示需要无限集合的计算了。</p><p>一种准确有效的方法是使用递归规则：</p><ol><li>先枚举若干个集合中的元素，（生成元）</li><li>使用若干条规则来从集合中已有的元素生成“新元素”，（生成法则）</li><li>对新生成的元素递归应用规则生成更多的元素。（递归运用）</li></ol><p>这样无限的集合就可以使用若干个生成元和有限的生成规则来表示了。比如自然数集可以用以下的方式来表示：</p><ul><li>0 表示第一个自然数</li><li>如果x是自然数，那么s(x)也是自然数</li></ul><p>这样我们就可以对所有的自然数进行编码了： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>→</mo><mi>s</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>2</mn><mo>→</mo><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">0\rightarrow 0, 1 \rightarrow s(0), 2 \rightarrow s(s(0)) \ldots </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span> </p><p>如果机器人需要使用递归规则表示无限集合，那么对集合元素的编码必须是<strong>结构化</strong>的，当然最好是同构的，这样才能让递归规则应用于所有生成的元素。同时机器人还需要理解和应用“<strong>变量</strong>”，因为规则本身的描述和应用需要声明“变量”，对“变量”赋值，并通过“变量”返回结果。</p><p>还有一种近似的表示无限集合的做法就是利用事物的特性来从一个“无限集合“映射到另一个”无限集合“。比如照相机可以把“无限”的场景视图映射到“无限”的二维图像；人类的感官系统可以把“无限”的现实状态映射大“无限”的主观认知状态。</p><h2 id="重表示机制"><a href="#重表示机制" class="headerlink" title="重表示机制"></a>重表示机制</h2><p>一个抽象概念可以用不同的编码机制来表示。比如人类编码自然数就使用了很多不同的表示方式。小朋友刚学数数时，用手指来表示自然数。人们口头交流时，使用的是不同语言对应的声音信号来表示自然数。计算机系统中，使用二进制来表示自然数。数学教学中，经常用数轴上的点来表示自然数。</p><p>显然不同的表示方法在不同的应用场景中的效率是不同的。为了更高效的表示和应用抽象概念，机器人也需要能够使用不同的方式来表示同一个抽象概念。同时也需要知道如何在不同的表示方式之间转换。最后还得知道什么场景下应该使用什么方式表示更高效，并作出相应的转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在机器人对世界进行建模时，不可避免的需要识别和编码各种抽象的概念。
即使是最最基础的事物，其特性都“隐含”有抽象的概念。 
比如思维时空中某一个点，它的特性中至少包含四个维度上离远点的距离，即坐标；还包含N个基础属性的强度。
由此可以看出，抽象概念并不是主体凭空想象出来的，而是客观世界的一部分。
虽然抽象概念不能在时空中&lt;strong&gt;独立存在&lt;/strong&gt;，但是时空中却处处都出现了抽象概念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="信息" scheme="http://blog.joypace.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
    <category term="抽象" scheme="http://blog.joypace.com/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>机器人的世界观</title>
    <link href="http://blog.joypace.com/2022/03/23/WolrdviewOfTheAgent/"/>
    <id>http://blog.joypace.com/2022/03/23/WolrdviewOfTheAgent/</id>
    <published>2022-03-23T06:48:50.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>通用智能机器人的需要在现实世界中完成各种任务，因此他需要对他所处的现实世界进行建模。我们为机器人设计的的数据结构和建模算法实际上隐含了机器人对这个世界的最核心的看法，即机器人的世界观。</p><span id="more"></span><h3 id="上帝视角看世界——四维空间中的果冻布丁"><a href="#上帝视角看世界——四维空间中的果冻布丁" class="headerlink" title="上帝视角看世界——四维空间中的果冻布丁"></a>上帝视角看世界——四维空间中的果冻布丁</h3><p>我们可以把现实世界可以看做是一个三维的同构空间和一维时间组合而成的<strong>四维异构空间</strong>。在这个四维空间中的每一个点都存在N种状态。这里，空间点的一种状态是指这个点上某种属性的值。常见的属性有质量密度，电荷密度，引力场强度，粒子的各种状态函数值等等。如果知道整个四维空间任意点的状态的话，整个世界的所有物理定律，历史，现在和未来都知道了。因为它们全都隐含在这些状态中了。</p><p>显然，我们无法真正获取这个四维空间当中每一个点的所有状态。我们甚至连N等于几都不能确定，更别说每一种状态的取值了。但是这并不妨碍我们定义:</p><ul><li>从现实世界的四维异构空间到四维向量空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>R</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">(t, x, y,z) \in R^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>的双射关系</li><li>从现实世界中的N种状态空间到M维向量空间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>S</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>M</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>C</mi><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">\vec{S}=(s_1, s_2, ...,s_M) \in C^M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span></span> 的双射关系，这里我们把现实世界中的状态中的向量全部为展开分量，如引力场展开为x,y,z三个方向的分量。</li></ul><p>现实空间的状态定义了一个从四维异构空间点到状态空间的映射关系。并且存在一个从四维向量空间到N维向量空间的函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><mi>S</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">f(t,x,y,z)=\vec{S} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> 与现实世界定义的映射关系同构。也就是说现实空间中的任何拓扑结构，都可以在向量空间同构的拓扑结构来表示。</p><p>我们可以将整个世界可以映射到一个边长为1的超立方体内，用不同的半透明的颜色来表示不同类型的状态，用亮度来表示状态的强度。这样整个世界的状态“看”上去就像一块四维空间彩色果冻布丁。想象一下，所有的历史，未来以及物理规律都隐含在这块果冻布丁里，是不是有点神奇？从四维空间的视角观察，整个世界是静态的，时间只是其中的一个维度而已，是不是有点宿命论的感觉？</p><p>如果我们把时间维度拿出来，每次只能观察到一个时刻的三位空间的话。沿着时间轴移动，观察到的这个半透明的彩色果冻布丁就变成了一个动态的模型了。</p><p>这里，我们可以形成机器人最底层的世界观：</p><ul><li>世界是一个三维空间（位置）</li><li>每个位置都可以存在N种状态（属性）</li><li>世界中的状态会随着时间维度动态变化，并且时间始终沿着未来方向前进（时间）</li></ul><p>这些底层世界观最终将体现在机器人的软件，硬件及数据当中。也就是说机器人的内在机制能够描述，应用这些最底层的世界观。比如他必须有机制来描述两个事件发生的相对时间顺序，发生的相对空间位置等等。</p><h3 id="现实中的挑战"><a href="#现实中的挑战" class="headerlink" title="现实中的挑战"></a>现实中的挑战</h3><p>理论上，如果我们能够使用某些方法在现实空间的中进行足够多的状态采样，就可以在向量空间的构建一个与现实世界同构的函数，从而完成对世界的建模。</p><p>实际上有很多现实的挑战需要处理,比如说：</p><ul><li>空间挑战<ul><li>精度和样本量的矛盾。空间上的点是一个无限小的概念，实际上无法测量无限小的位置的状态。并且精度越高，相同“体积”内需要采样的样本数就越高。</li><li>不是任何位置都是可达的。物体内部，离主体很远的位置，过去，未来的状态对于当下来说都是不可达的</li></ul></li><li>测量挑战：<ul><li>很多属性是不能被主体直接测量的</li><li>测量动作本身也会改变时空中的状态</li></ul></li><li>认知挑战：主体开始都不知道某些属性的存在</li><li>计算挑战：即使我们采到足够多，足够细粒度，足够高精度的历史样本，直接从最底层的点来计算为了达成目标需要执行的计划，计算上也是不可行的。</li></ul><p>为了应对这些挑战，主体必须利用其他机制对世界进行建模。</p><h3 id="主体视角看世界——事物在物理定律的约束下相互作用"><a href="#主体视角看世界——事物在物理定律的约束下相互作用" class="headerlink" title="主体视角看世界——事物在物理定律的约束下相互作用"></a>主体视角看世界——事物在物理定律的约束下相互作用</h3><p>简单来说，我们可以从两个方面来迎接上面的挑战。首先，机器人是为了完成人类为其设定的目标的，因此，所有和实现机器人目标不相关的挑战可以简单的不予处理。比如很久以前的历史，遥远的未来，外星系的事件，基本粒子的属性等等。其次，也是最关键的是利用物理世界本身的特性。</p><ol><li><p>物理世界的状态分布符合其内在的一致性规律——物理定律，可以部分解决空间挑战，测量挑战和认知挑战</p><p> 物理世界存在若干个基础定律，世界中的各种属性的状态必须满足这些这些定律的约束。 物理定律的存在，导致世界的状态中存在大量重复的Pattern， 机器人通过观察这些pattern，可能总结归纳出这些定律 通过这些定律，能够基于一部分已知的状态推理出对应的未知状态 通过观察pattern和构造规律假说，可以推理出与当前pattern相关，主体之前却不知道的属性。</p></li><li><p>整体，局部与结构——解决计算挑战</p><p> 把细粒度的事物，概念在特定的结构下形成的整体作为认知和建模对象，可以使建模的效率大幅提升，推理的复杂度大幅降低。 通常情况下，整体不是其局部简单的汇总，而是会形成整体特有的特性，即<strong>整体特性</strong>。 并且这些整体特性同样会表现出明显的一致性。 这一特点使得主体可以忽略组成物体的细节，直接在整体特性层面寻找和发现规律，从而大大简化主体认知，推理的计算需求。 同时，模仿这些结构，主体还可能创造性的形成新的整体，比如发明自然界不存在的物品（创造性），构想出现实世界中不可能存在的事物（想象力）。 <strong>整体特性的使得主体从多个“合适”的粒度出发，“并发”地探索世界变得可能。</strong></p><p> 将一定时空内的特定属性聚合在一起，当成整体来考虑可以大大简化主体推理的计算需求。 我们把聚合在一起的属性整体叫做<strong>物体</strong>。 注意这里我们对这个聚合没有任何特别的限制，任何属性都可以聚合在一起。 从这个方面来看，物体是一个主观概念，它只是一些基础属性的<em>载体</em>。 一旦你用某种机制“定义”了这个载体的范畴，它对应的属性集合是绝对的客观事实， 从另外一个方面来看，因为主体定义物体的目的是简化计算和推理，因此实际定义物体时，总是会遵循一些基本原则使得的定义的物体更有用。 我们也可以聚合特定的物体从而定义更复杂的新的物体。 虽然物体整体特性是局部特性在特定结构下相互作用的结果，但它往往是任何局部都无法单独体现的特性。 很多时候，物体的整体特性在事物之间的相互作用过程中表现出明显的一致性规律。 （注意，整体特性并不是主体主观定义的，而是物体的内部各个部分相互作用的客观结果。） 物体的定义使得世界“变得”丰富多彩，而不再“看上去”只是若干种基础属性在四维空间中的分布。</p><p> 将特定时空集合总的相关物体、属性及其动态变化的过程聚合起来当成整体考虑，就形成<strong>事件</strong>。通过关注事件相关的事物，可以使得主体将计算资源集中在一个相对可控的范围，从而更可能完成其特定的目标，比如发现规律，搜索目标对象，推理事件发展等等。类似于物体的情况，事件本身也可以通过组合形成更复杂的事件。整体事件也会具有其子事件不具有的整体特性。</p></li></ol><p>现在，机器人的世界观扩展为：</p><ul><li>世界上存在<strong>事物</strong>——物体和事件</li><li>世界所有<strong>事物</strong>在物理定律的约束下相互作用</li><li>可以使用任何合适粒度的来对世界进行建模</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;通用智能机器人的需要在现实世界中完成各种任务，因此他需要对他所处的现实世界进行建模。
我们为机器人设计的的数据结构和建模算法实际上隐含了机器人对这个世界的最核心的看法，即机器人的世界观。&lt;/p&gt;</summary>
    
    
    
    
    <category term="世界观" scheme="http://blog.joypace.com/tags/%E4%B8%96%E7%95%8C%E8%A7%82/"/>
    
    <category term="主体架构" scheme="http://blog.joypace.com/tags/%E4%B8%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>因果关系与一致性</title>
    <link href="http://blog.joypace.com/2021/11/17/CausalEffectAndConsistency/"/>
    <id>http://blog.joypace.com/2021/11/17/CausalEffectAndConsistency/</id>
    <published>2021-11-17T08:31:18.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>世界上任何事物都遵循特定的物理规律而运作是我们的一个最基础的假设。在这个前提下，任何事物的出现或发生都是由于一系列前置事物导致的，同时也会影响后续事物的发展。我们称前置事物为“原因”，后续事物为“结果”。原因和结果之问的关系称之为因果关系。很显然发现和应用因果关系对于智能机器人来说非常重要。</p><span id="more"></span><p>因果关系的一个重要特点是它们是概率性的。当然有很多因果关系它的因果确定概率极为接近1,我们称之为确定性因果关系。很多自然科学中的物理定律都为确定性的，如牛顿三大定律，基础电学。同时也有不少因果关系是按某些概率密度函数分布的，如量子微观世界中的各种规律。</p><p>因果关系的另一个重要的特点是其复杂性，主要体现在两个方面：无限的因果链，庞大的相互作用网络。</p><p>“无限”的特性体现任何原因都有其自身的原因，任何结果会产生新的结果｡同时任何因果关系都可以不断细化，似乎永远无法确定有真正的直接因果关系。 比如为什么我看到眼前这个苹果是红色的？因为光线从这个红色苹果反射到我的眼睛里。为什么光线反射到眼睛里就是红色？不是所有光线进入眼睛都是红色，而是特定波长的光进入眼晴才能会让人认为是红色的。为什么是红色而不是蓝色光反射出来？因为成熟苹果表皮含有……理论上我么可以不断细化下去，知道我们不知道更底层原因了，当然不知道并不认为原因不存在了。</p><p>相互作用的网络是指现实生活中绝大部分现象都不是由单一的原因造成的，通常都是由一系列相互关联的事物共同作用而产生的。这也是为什么物理课上经常要强调在理想环境下，把物体简化为质点等来讨论物理定律与相关推理。同时任何事件产生的结果也不会是单一的，而是一系列直接和间接的其他结果。如我们开空调不仅仅是房间里变凉快了，屋外也更热了，不仅消耗了电力，同时也可能消耗了不少煤炭，释放了不少温室气体等等。</p><p>因果关系的这些特点导致未来可预测确有无法准确预测，真实环境的因果分析成本很高，觉大部分时候，实时分析和推测是不切实际的。</p><p>因此，在日常生活中，人们通常不是精细地，准确的利用因果关系，而是简化地、粗略地利用其总体效果，即一致性。比如人们骑自行车的时候，大部分人根本不知道而且也不需要知道自行车行进时为什么不容易倒下的物理原理，人们基本依赖练习时体会到的一些直觉来保持平衡，如依靠速度，身体重心的微调，手把的转动。其实这就是人们常说的经验主义，虽然这是在学术界和技术工程领域经常被批评的一种工作态度，但它确实是一种必要的生存技能，实际上非常多的科学理论都是建立在经验主义基础之上，比如化学，空气动力学等等。</p><p>让机器人能够发现和利用日常生活中的一致性是开发通用机器人很关键的一步。机器人需要能够发现一致性的现象，识别该现象出现的前提和常见的结果，该现象在不同条件下出现的概率（概率越高，决策分析时尝试使用它的可能性越大），以及出现不一致时或意外时如何改进，更新或者抛弃该一致性假设。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;世界上任何事物都遵循特定的物理规律而运作是我们的一个最基础的假设。
在这个前提下，任何事物的出现或发生都是由于一系列前置事物导致的，同时也会影响后续事物的发展。
我们称前置事物为“原因”，后续事物为“结果”。原因和结果之问的关系称之为因果关系。
很显然发现和应用因果关系对于智能机器人来说非常重要。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="因果关系" scheme="http://blog.joypace.com/tags/%E5%9B%A0%E6%9E%9C%E5%85%B3%E7%B3%BB/"/>
    
    <category term="一致性" scheme="http://blog.joypace.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>为什么让机器看见事物很难</title>
    <link href="http://blog.joypace.com/2021/09/12/WhyIsItHardToMakeAMachineSee/"/>
    <id>http://blog.joypace.com/2021/09/12/WhyIsItHardToMakeAMachineSee/</id>
    <published>2021-09-12T02:39:13.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>对于人类来说，看见周围的事物似乎是非常简单的事情。比如我能够轻松的看见眼前的笔的轮廓，笔尖的形状，墨水随着笔尖的移动流畅地出现在纸面上，呈现出一个个的汉字。我能清晰地看见手掌上错综复杂的纹路杂乱无章的交错着。如果我面前出现一个从来没见过的东西，我也能很轻松的看到他的形状，色泽，纹理等等，虽然我们不知道它具体是什么东西，有什么用。这一切对于我来说是那么自然和轻而易举，根本不需要任何思考和努力。</p><span id="more"></span><p>可是当我回顾自己是怎么做到从一帧一帧的图片中看见事物时，却发现无法获得任何有用的信息。很显然我们的大脑做过大量的计算，但并没有将这些行为和信息暴露给上层的思考相关的“进程”。这说明大脑的功能至少可以分为两层，通过某种接口层交互。在接口层之下，一切都是自动的，可以使用大量我们自己都不理解的技术。在接口层之上，则是我们意识到的各种信息，可以回顾，假设，推理，纠正错误等等。对于接口层来说，则需要其提供的信息是可验证的（至少大部分时候）。也就是说，我虽然不知道底层是怎么样做到的，但我能验证底层给的信息是有效的。比如，我虽然不知道底层怎么快速找出来我眼前的笔的影像的，但是我能够验证这个判断是对的。曲线就是笔的轮廓，曲线内部的蓝色像素是笔的颜色，外部是其他纸，墨水，手产生的像素。如果我移动手，手和笔都会移动，而本子不会移动。</p><p>视觉底层带来的好处是高效，快速.缺点也比较明显，出现错误或歧义时很难甚至无法给它反馈和纠正错误。比如下面这个动画中的三个齿轮，但看上去一直在转，实际上除了背景和齿轮边缘的亮度在变化之外，其他部位都没有动。即使已经知道了这些齿轮是静止的，我们好像都无法反馈给底层。我们的大脑还是不断告诉我们齿轮在动。<img src="/images/three_gears_illusion.gif"></p><p>当然有时候我们也能给底层一些反馈，比如预设的假设或偏见。我们来看看下面这张图动画，它分为三个部分。中间的部分是一个旋转的舞者的投影，无论顺时钟，逆时钟或者来回摆动都能产生这个投影。如果你盯着左边和中间部分，你会觉得中间的舞者的旋转方向和左边的一致。如果你盯着右边和中间部分，你又会觉得中间的舞者的旋转方向和右边的一致。<img src="/images/rotating_dancer_illusion.gif"></p><p>正是因为底层这个黑盒的存在，使得我们很难通过直接模仿（山寨）人脑来让机器人看见事物。尤其是想直接从像素矩阵映射到物品类别或实例时，涉及到跨好几个域的映射关系，就更加困难了。反过来想，底层黑盒的存在又让机器人的设计相对简单一些。因为我们可以使用任何技术来实现这个底层，而不用担心机器人自己不理解这些底层。比如利用已知的光学，数学知识，整体部分关系甚至使用深度学习来构建这个底层。当然接口层的设计非常关键，这决定了机器人能够有意识的应用的最底层的特征集。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于人类来说，看见周围的事物似乎是非常简单的事情。
比如我能够轻松的看见眼前的笔的轮廓，笔尖的形状，墨水随着笔尖的移动流畅地出现在纸面上，呈现出一个个的汉字。
我能清晰地看见手掌上错综复杂的纹路杂乱无章的交错着。
如果我面前出现一个从来没见过的东西，我也能很轻松的看到他的形状，色泽，纹理等等，虽然我们不知道它具体是什么东西，有什么用。
这一切对于我来说是那么自然和轻而易举，根本不需要任何思考和努力。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="视觉" scheme="http://blog.joypace.com/tags/%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>我们能够描述所有事物吗？</title>
    <link href="http://blog.joypace.com/2021/08/21/CanWeDescribeEverything/"/>
    <id>http://blog.joypace.com/2021/08/21/CanWeDescribeEverything/</id>
    <published>2021-08-21T04:04:56.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>智能机器人需要在现实世界中完成各种目标，其中很多目标是在系统的设计阶段是还不知道的。因此一个必须面对的挑战是设计一套信息编码机制来描述所有的与已知或未知的目标相关事物。</p><span id="more"></span><p>我们首先需要回答的是：能否设计出一种机制，可以用来描述所有事物？答案好像是不知道。因为当你都不能确认所有的事物有什么时，你好像无法证明你的方法可以描述所有的事物。反过来说，你没有找到这种方法也不能表示这种方法不存在。就像在没发现黑天鹅之前，我们不能说黑天鹅一定不存在。</p><p>虽然这个回答让人感到失望，还好我们的目标不需要那么宏大。我们只需要设计一种信息编码机制，能够描述人类能够描述或想象的所有事物就行。并且我们可以很有信心的说这种信息编码机制一定存在。地球上每一个人都是一个实例，证明了它们的存在。</p><p>一种可能的方法是对已知事物进行分类，然后针对性的设计编码机制，再组合使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;智能机器人需要在现实世界中完成各种目标，其中很多目标是在系统的设计阶段是还不知道的。
因此一个必须面对的挑战是设计一套信息编码机制来描述所有的与已知或未知的目标相关事物。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="信息" scheme="http://blog.joypace.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>常识很重要</title>
    <link href="http://blog.joypace.com/2021/08/19/CommonSenseIsVital/"/>
    <id>http://blog.joypace.com/2021/08/19/CommonSenseIsVital/</id>
    <published>2021-08-19T21:50:37.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>在百度百科里，常识是这样定义的：常识具体指的是在一个社会环境中人与人之间普遍存在的日常共识，而无论是任何学术问题或是人与人之间基本交流都是基于常识上来做进一步探讨的。</p><span id="more"></span><p>家政机器人的一个很重要的目标就是和人类交流。</p><p>机器人需要通过和人类交流来获取</p><ul><li>需要完成的任务，以及任务的具体要求</li><li>完成任务是得到反馈</li><li>遇到困难时得到帮助</li></ul><p>真正友好、高效的交流是依赖大家对信息的一致理解，并且足够的默契。理解不一致，就会出现很多鸡同鸭语，对牛弹琴的无奈。不够默契就是常识不一致了，让人感觉费力又低效。想象一下你和机器人说帮我把T恤上的墨迹清理掉，然后他拿把剪刀把那块直接剪掉了。或者你让他扫一下地，需要告诉他地上哪些是垃圾需要扫到垃圾桶，那些掉落的物品需要捡起来，每张凳子需要怎么放……也许第一次你能接受，但每次都这样就没人能接受了。因此，要制造出真正可用的家政机器人，必须让他用能力快速地学会各种情景下的各种常识。</p><p>对于人类来说常识好像很简单，实际上却非常难。人类自己基本上都不知道自己的常识是怎么“不知不觉”获取到的。因此设计机器人并让他学会常识就更难了。</p><ul><li>首先，常识涉及的面非常广，几乎不可能给一个完整的列表，然后说学会这些就够高了。</li><li>常识动态变化的。于不同的主体交流，在不同的时间，不同的地点以及不同的任务中，常识的内容都可能发生变化</li><li>不断会有新的常识产生，旧的常识消亡</li></ul><p>因此，我们需要设计一套机制，使得机器人能够</p><ul><li>即时学会常识，并且能够现学现用（实时更新）</li><li>能够知道每一个常识的适用范围</li><li>在日常交流和工作中正确的应用</li><li>能够不断更新自己的常识库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在百度百科里，常识是这样定义的：常识具体指的是在一个社会环境中人与人之间普遍存在的日常共识，而无论是任何学术问题或是人与人之间基本交流都是基于常识上来做进一步探讨的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="常识" scheme="http://blog.joypace.com/tags/%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>不存在完美，足够好就行</title>
    <link href="http://blog.joypace.com/2021/08/17/ThereIsNothingPerfect/"/>
    <id>http://blog.joypace.com/2021/08/17/ThereIsNothingPerfect/</id>
    <published>2021-08-17T04:13:19.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>我经常吐槽所谓的智能设备根本不智能，因为它们根本不理解这个世界。然后我就开始找理由来说明我确实理解这个世界。结果发现我好像也没有我想象那么理解这个世界。</p><span id="more"></span><p>比如我理解我面前的显示器为什么能显示不同的图像，因为屏幕面板上有很多红绿蓝的发光晶体管。然而我却不知道为什么这些晶体管会发出红绿蓝的光。我认为我理解电脑桌是松木做的，木料来自于砍伐的松树。然而我却不知道松树是怎么神奇地从土地，大气，阳光中汲取养分生长大树的。我越想越觉得自己好像也不那么智能了……</p><p>这时，突然想到年轻的时候喝过的鸡汤，咱不追求完美，只追求卓越。是的，我只是想做一个家政机器人帮我做做家务而已，够用就行了。</p><p>现在问题就变成怎样才算足够好呢？足够好的参考点是什么？在我看来，这个参考点只能是相应的目标了。</p><p>比如我们要制作一个电脑桌，那对于测量精度要求到毫米就足够了。如果我们要制作芯片，那精度到纳米级才可能算足够好。对于事物的理解也是类似的。对于家政机器人来说，他需要理解日常生活中的很多事物，如人类，家具家电，衣物，房屋等等。但他对这些事物的理解只需要能够让他顺利完成他的日常工作和必要时向他人求助就够了。家政机器人不需要成为一名医生，家电维修工程师，裁缝……</p><p>我们在设计机器人的”思考，规划，行动“机制时，尤其是探索”因果关系“时，需要注意机器人的”精力“不要陷入”无尽“的探索中。比如小朋友问机器人：我从哪里来的？机器人答：妈妈生的？小朋友问：妈妈哪来的？答：外婆生的？问：外婆哪来的？答：外婆的妈妈生的？问：那第一个人哪来的？答：从猿进化来的？问：那第一个猿哪来的？答：……家政机器人在类似情况下，如果有更优先的目标，应该在适当的时候”投降”，说我也不知道。当然能鼓励小朋友自己去探索就更好了。</p><p>在制定行动计划时，也不用要求最完美的计划，而是够好就行了。类似的，在视觉识别时不用每一个像素都需要百分百确认它是怎么产生的，不用每一个物体的边缘位置都有精确到“像素”级别。常识获取上也是类似的，不用搞清楚每一个事物每一个方面。</p><p>总之，足够好就行，不够好就改进。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我经常吐槽所谓的智能设备根本不智能，因为它们根本不理解这个世界。
然后我就开始找理由来说明我确实理解这个世界。
结果发现我好像也没有我想象那么理解这个世界。&lt;/p&gt;</summary>
    
    
    
    
    <category term="思考" scheme="http://blog.joypace.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="足够" scheme="http://blog.joypace.com/tags/%E8%B6%B3%E5%A4%9F/"/>
    
    <category term="完美" scheme="http://blog.joypace.com/tags/%E5%AE%8C%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>怎样才算&quot;看见&quot;？</title>
    <link href="http://blog.joypace.com/2021/08/12/WhatDoWeMeanBySee/"/>
    <id>http://blog.joypace.com/2021/08/12/WhatDoWeMeanBySee/</id>
    <published>2021-08-12T08:33:12.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>智能机器人必须要”看见”这个世界，才能在这个世界实现他的各类目标。那怎么样才算”看见”这个世界呢？照相机拍下照算”看见”吗？摄像头录下视频算”看见”吗？我觉得这都不能算”看见”，只能算<em>记录</em>下了影像信息。“看见”的结果应该是对所见的场景有足够的理解，使得主体能够采取合理的行动以达到其相应的目标。</p><span id="more"></span><p>这里，相机和摄像头本身都不是主体，只是人类发明的”机械”工具。因为相机和摄像机没有我们认为的足够有意义的通用目标。即使相机和摄像头是智能机器人的一部分，相片和视频本身也不能算”看见”，而只能算原始视觉信号。因为从相片的像素矩阵到机器人理解这个场景还需要很多复杂的信息处理流程。</p><p>现在我们来看另外一个场景。</p><p><em>一只小鸟正在院子里的葡萄藤上啄葡萄。一个小姑娘看见了，从屋内跑出来，大喊着：”走开！走开！你这只馋嘴的小鸟，不要吃我家的葡萄！”小鸟看见有人来了，赶紧飞走了。</em></p><p>这里，我们可以推断出：小鸟和小姑娘都”看见”了各自目标须要看见的事物，并且都采取了合理的行动来达成各自的目标。</p><table><thead><tr><th align="left">主体</th><th align="left">目标</th><th align="left">看见什么</th><th align="left">可能未看见</th></tr></thead><tbody><tr><td align="left">小鸟</td><td align="left">吃葡萄</td><td align="left">葡萄</td><td align="left">屋里的小女孩</td></tr><tr><td align="left">小姑娘</td><td align="left">赶走小鸟</td><td align="left">小鸟在吃葡萄<br>通往葡萄架的路<br>小鸟飞走了</td><td align="left">葡萄藤上成熟的葡萄</td></tr><tr><td align="left">小鸟</td><td align="left">逃跑</td><td align="left">小姑娘跑出来<br>逃跑的路径无障碍（路径上<strong>没看见</strong>障碍）</td><td align="left">旁边有更多的葡萄</td></tr></tbody></table><p>因此，从设计机器人的角度来看，”看见”意味着机器人需要将检测到的环境信号，转换成有效的环境模型，用于实现其目标。</p><ul><li>目标包括机器人当前目标和基于当前环境统计的常见目标。<br> 比如小鸟吃葡萄时，应该选择好了逃跑的路线。<br> 小姑娘看见小鸟吃葡萄，马上就”看见”了出去的路。  </li><li>环境模型应该是易于机器人作决策使用的数据结构。<br> 比如存在什么东西，发生了什么事情，这些事物与目标的关系等等</li><li>作为外部检验方式，可以观察机器人：<br> 利用了哪些事物？<br> 达成了哪些目标？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;智能机器人必须要”看见”这个世界，才能在这个世界实现他的各类目标。
那怎么样才算”看见”这个世界呢？
照相机拍下照算”看见”吗？
摄像头录下视频算”看见”吗？
我觉得这都不能算”看见”，只能算&lt;em&gt;记录&lt;/em&gt;下了影像信息。
“看见”的结果应该是对所见的场景有足够的理解，使得主体能够采取合理的行动以达到其相应的目标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="看见" scheme="http://blog.joypace.com/tags/%E7%9C%8B%E8%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>什么是信息</title>
    <link href="http://blog.joypace.com/2021/07/31/AboutInformation/"/>
    <id>http://blog.joypace.com/2021/07/31/AboutInformation/</id>
    <published>2021-07-31T06:22:54.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>（本文中的机器人可以使用主体替换，大部分时候结论也成立）</p><p>机器人是一个目标导向系统，他的全部行为都围绕着如何合理地实现他的各种目标而展开。机器人的行为可以分为两类：信息处理和动作执行。信息处理部分是最有挑战性的部分。梳理清楚信息的定义和作用对与设计机器人是非常重要的。</p><span id="more"></span><h2 id="信息的定义"><a href="#信息的定义" class="headerlink" title="信息的定义"></a>信息的定义</h2><p>从机器人的角度来看，信息是对事物的描述。</p><p>信息需要使用特定的载体来承载，使用特定的编码来表达不同的描述。信息描述的对象或事物称为信息的语义。人类语言（口语）就是一种非常常见的信息。语言的载体是声音（空气的震动），编码是人们日常生活中约定的各种表达方式，如普通话，各地方言，英语等等。</p><p>对于机器人来说，信息可以分为内部信息和外部信息两大部分。所有外部信息都需要转化为内部信息后，才能被机器人的信息处理系统处理。内部信息就是机器人内部的数据，一般包括机器人的经验，知识，环境模型，目标描述等等。外部信息是机器人与主体交流时，在特定的载体上使用特定的编码机制生成的信息。常见的外部信息有语言，肢体语言，图像，视频等等。我们可以从事物中提取出很多非常有价值的信息，也可以用各种事物来记录信息。<br>⚠️但是一般来说事物本身并算是信息。</p><p>信息可以描述客观存在的事物，也可以用来描述不存在的事物。如”现在，我面前有一个iPad”描述的是客观存在的事物。我更喜欢用我的MacBook来写博客，所以我很希望”现在我面前有一台MacBook”。后面这个信息描述的就是不存在的事物。</p><h2 id="信息的作用"><a href="#信息的作用" class="headerlink" title="信息的作用"></a>信息的作用</h2><p>任何事物的作用，都是相对于某一个目标而言的。对于目标导向的机器人来说，信息的作用体现在很多方面，最终全部都要体现在如何让机器人完成给定的目标上来。</p><h3 id="内部信息的作用"><a href="#内部信息的作用" class="headerlink" title="内部信息的作用"></a>内部信息的作用</h3><ul><li>描述目标及其完成状态。<br>大部分目标实际上就是对未来某一时刻某一位置的相关事物的期望状态的描述。<br>还有不少目标是对事物之间的各类关系的描述。<br>主体需要通过特定的方式，把这些描述标记为目标，并追踪其实现状态。  </li><li>描述环境的状态。<br>对物体的位置，大小，动态和静态特性建模。<br>对周边的温度，湿度，磁场，力场等等进行建模。<br>对环境中的主体，安全性进行建模等等。   </li><li>描述环境中的规律。<br>对周边的物体的运行规律建模。<br>对周边人物的性格和为人处事规律进行建模。<br>对宇宙中的各种物理，化学，人文现象进行建模。  </li><li>描述推理过程和执行计划。<br>  记录推理过程，使得主体得以回顾和总结寻找解决问题的过程中高效和低效的做法，  从而提高未来解决类似问题的效率。<br>  对执行计划的描述使得主体得以”有效”的行动来改变世界，达成目标。</li></ul><h3 id="外部信息的作用"><a href="#外部信息的作用" class="headerlink" title="外部信息的作用"></a>外部信息的作用</h3><ul><li>信息交换使得每个主体能够获取的知识远远大于主体自己独自探索世界能获取到的。  </li><li>信息交互使得主体之间有效合作成为可能。<br>主体之间相互合作能够完成很多单一主体无法完成的任务。有效的合作需要合理的分工，配合，这一切都依赖主体之间有效的信息交互。</li></ul><h2 id="信息理解"><a href="#信息理解" class="headerlink" title="信息理解"></a>信息理解</h2><p>这个话题参考”关于理解”的博客</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;（本文中的机器人可以使用主体替换，大部分时候结论也成立）&lt;/p&gt;
&lt;p&gt;机器人是一个目标导向系统，他的全部行为都围绕着如何合理地实现他的各种目标而展开。
机器人的行为可以分为两类：信息处理和动作执行。
信息处理部分是最有挑战性的部分。
梳理清楚信息的定义和作用对与设计机器人是非常重要的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="信息" scheme="http://blog.joypace.com/tags/%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>基础假设</title>
    <link href="http://blog.joypace.com/2021/07/31/BasicAssumptions/"/>
    <id>http://blog.joypace.com/2021/07/31/BasicAssumptions/</id>
    <published>2021-07-31T01:56:10.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>一台通用的目标导向的智能机器人，从系统设计层面来看，应该分为三层，硬件层，软件层和数据层。正常情况下，硬件层和软件层算”硬编码”的，及系统设计是确定下就很难改变的，决定机器人的能力上限。数据层则对应着机器人日常积累的各种经验，知识和技巧，体现机器人当前的能力水平。 我们对机器人所处客观环境的基础假设就隐含在机器人的硬件和软件设计当中，或者说隐含在软硬件结合的行为当中。</p><span id="more"></span><p>我认为在设计和制造机器人是应该可以毕竟安全的隐含以下假设</p><h2 id="时空假设"><a href="#时空假设" class="headerlink" title="时空假设"></a>时空假设</h2><p>所有的事物都在一个三维的空间容器当中，并沿着时间维度向未来单向地动态变化。</p><p>空间假设的存在使得系统可以使用三维向量加合适的单位来描述事物之间的相对空间位置。时间的单向变化使得系统可以使用数字加合适的单位来描述事件发生的相对时间，并在制定行动计划，分析事物规律时依赖”现在的行为可以改变未来的事件，而过去的事件以已经无法改变”。</p><h2 id="物质和物体假设"><a href="#物质和物体假设" class="headerlink" title="物质和物体假设"></a>物质和物体假设</h2><p>物质是物理属性的最终载体，及物质在特定的空间和时间存在导致在特定的属性在相应的空间和时间出现，从而导致更多相应的属性出现在相应的空间和时间。至于到底有多少类型的物质？总量有多少？有多少属性？这些都是需要机器人去学习和发现的。</p><p>特定数量的各种物质或物体的集合可以组合成更复杂的新物体，组成物体的子部分的属性和特性作为一个整体能够产生新的特性。机器人的大部分时候需要学习和利用周围物体的特性，并利用这些特性达到其具体的目的。</p><p>机器人本身是各类物体中的一种。</p><h2 id="一致性假设"><a href="#一致性假设" class="headerlink" title="一致性假设"></a>一致性假设</h2><p>时空中的各种事物遵循一致性的客观规律相互作用，动态变化。注意，世界上存在两种一致性，即统计一致性和确定一致性。</p><p>对于复杂系统的行为和需求预测很多都是统计性的，如人们对于事物的喜好判读，天气预测等。 当然，量子力学领域也有大量的统计性规律，不过目前来看基本与机器人的设计没有关系。</p><p>当然生活中还有很多事物是遵循相对简单的确定性特性，如把衣服放洗衣机内，按开始按钮后，衣服会在确定的时间内洗完。注意，这里的确定性并不是说不存在误差，而是指误差容忍范围内的确定性。</p><p>机器人需要能够学习和发现这两类一致性规律，基于着一致性来做出合理的决策，并在出现意外地不一致的情况下查找原因并解决可能的问题。比如洗衣机没在指定时间内洗完，可能是门没关紧或者洗衣机坏了，机器人需要把门关好或者使用其它方法洗好衣服。</p><h2 id="交互假设"><a href="#交互假设" class="headerlink" title="交互假设"></a>交互假设</h2><p>机器人只能通过感应器来获取环境的部分状态，机器人需要基于合理的假设来推断，建立和验证相关环境的模型。也就是说机器人不能神奇的获取外部世界的模型和规律。</p><p>机器人只能通过其运动系统或信息系统（如语言）产生的行为来影响外部环境。</p><h2 id="主体假设"><a href="#主体假设" class="headerlink" title="主体假设"></a>主体假设</h2><p>由于机器人大部分情况下是在人类社会中为人类服务，因此机器人默认假设世界上存在目的导向的主体，遵循一些主体相关的统计性规律，能够让机器人更好的与人类和其他主体交互。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一台通用的目标导向的智能机器人，从系统设计层面来看，应该分为三层，硬件层，软件层和数据层。正常情况下，硬件层和软件层算”硬编码”的，及系统设计是确定下就很难改变的，决定机器人的能力上限。数据层则对应着机器人日常积累的各种经验，知识和技巧，体现机器人当前的能力水平。 我们对机器人所处客观环境的基础假设就隐含在机器人的硬件和软件设计当中，或者说隐含在软硬件结合的行为当中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
    <category term="假设" scheme="http://blog.joypace.com/tags/%E5%81%87%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>什么是目标导向系统</title>
    <link href="http://blog.joypace.com/2021/07/28/AboutGoalOriented/"/>
    <id>http://blog.joypace.com/2021/07/28/AboutGoalOriented/</id>
    <published>2021-07-28T13:16:50.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>我认为目标导向是通用人工智能系统最核心的概念。不幸的是我发现自己无法找到一个准确的定义。或者说我无法找到一个定义能把我认为明显不是目标导向的物体排除出去。</p><p>最开始我认为，一个实体有一个目标，并能采取适当的行动达成这个目标，那这个实体就可以算是目标导向系统了。然后我发现，根据热力学第二定律，整个宇宙的熵将会不断增加，也就是说一块石头，我们也可以说它有一个目标就是熵最大化，它为了达到这个目的的行为就是耐心地等待。别小看石头这种等待的行为，实际上已经很多石头取得了很大的进展，如沙漠里很多沙子都是风化了的石头。</p><span id="more"></span><p>我曾经为了排除像石头，桌子这些”没什么意义”的物体，我尝试把目标导向的定义改为一个实体能够设定合理的目标，并采取行动达成目标。发现居然还是不能排除石头。因为我们可以说熵最大化是合理的目标，并且我们如果相信热力学第二定律的话，石头采取的行动最终确实能达成目标。我不得不承认所有的物体都算一种目标导向系统。</p><p>至此，我放弃在定义上给区分我认为有价值的目标导向系统。因此，我们需要一些评价标准来评价不同目标导向系统的价值。因为价值是目标相关的判断，因此也无法给出一个统一的标准来评判目标导向系统是否有价值。</p><p>比如我希望制造出一个目标导向系统来帮助我达成一些目标，如扫地，做饭，洗衣服，因此，对于我的这些目标而已，一个实体能完成多少类型的相关任务，能够在多快时间内完成，能够用多低成本完成都是一些很重要的评判标准。</p><p>从大多数人的角度来看，石头这类目标导向系统没什么意义，大部分有生命的系统比非生物的目标导向系统更加有意义。（PS：生命本身也是一个无法准确定义的概念）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我认为目标导向是通用人工智能系统最核心的概念。不幸的是我发现自己无法找到一个准确的定义。或者说我无法找到一个定义能把我认为明显不是目标导向的物体排除出去。&lt;/p&gt;
&lt;p&gt;最开始我认为，一个实体有一个目标，并能采取适当的行动达成这个目标，那这个实体就可以算是目标导向系统了。然后我发现，根据热力学第二定律，整个宇宙的熵将会不断增加，也就是说一块石头，我们也可以说它有一个目标就是熵最大化，它为了达到这个目的的行为就是耐心地等待。别小看石头这种等待的行为，实际上已经很多石头取得了很大的进展，如沙漠里很多沙子都是风化了的石头。&lt;/p&gt;</summary>
    
    
    
    
    <category term="目标导向" scheme="http://blog.joypace.com/tags/%E7%9B%AE%E6%A0%87%E5%AF%BC%E5%90%91/"/>
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>目标导向系统</title>
    <link href="http://blog.joypace.com/2021/07/12/GoalOrientedSystem/"/>
    <id>http://blog.joypace.com/2021/07/12/GoalOrientedSystem/</id>
    <published>2021-07-12T01:09:55.000Z</published>
    <updated>2022-03-27T15:04:12.775Z</updated>
    
    <content type="html"><![CDATA[<p>我理想中的通用智能机器人，应该是目标导向的。即你告诉机器人目标之后，他自己想办法在合理的时间内花费合理的代价完成目标。比如我让他帮我洗衣服，我只需要说出目标就行了，不需要我教他一步一步怎么做。他可以在我们协商好的地方找到脏衣服，然后使用家里的洗衣机和洗涤剂洗衣服，洗完后拿到阳台晾晒，晾干后把衣服折好并按类别放到衣柜里。当然整个过程中如果有不确定的地方，他可以找我商量该怎么处理。<span id="more"></span></p><p>这个通用智能机器人还应该是多目标导向的，即他可以同时接受多个任务，并合理时间内按照合理的优先级完成。也就是说我只需要一台这样的机器人就能让他完成洗碗，做饭，洗衣服，收拾房间等多种类型的任务，甚至还可以让他照顾家里的小孩和老人。当然，你也可以让他和你一起探索宇宙的奥秘，探讨人生的意义。</p><p>理想的通用智能机器人还应该有非常友好的人机交互机制。你可以和他用母语，动作甚至神态进行交流。你也可以和他形成个人之间的默契，就像和你的好朋友之间一样。</p><p>最后，也是最重要的一点，就是机器人必须非常非常的安全可靠。他不会对你，你的家人，你的朋友以及他人造成伤害，也不会对动物，植物，物品和环境造成伤害。</p><p>总之，通用智能机器人应该是目标导向的，他需要通过学习和探索找到完成各种目标的方法，或这甄别无法完成的目标，再通过合理的行动来完成目标。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我理想中的通用智能机器人，应该是目标导向的。即你告诉机器人目标之后，他自己想办法在合理的时间内花费合理的代价完成目标。比如我让他帮我洗衣服，我只需要说出目标就行了，不需要我教他一步一步怎么做。他可以在我们协商好的地方找到脏衣服，然后使用家里的洗衣机和洗涤剂洗衣服，洗完后拿到阳台晾晒，晾干后把衣服折好并按类别放到衣柜里。当然整个过程中如果有不确定的地方，他可以找我商量该怎么处理。</summary>
    
    
    
    
    <category term="目标导向" scheme="http://blog.joypace.com/tags/%E7%9B%AE%E6%A0%87%E5%AF%BC%E5%90%91/"/>
    
    <category term="概述" scheme="http://blog.joypace.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
</feed>
